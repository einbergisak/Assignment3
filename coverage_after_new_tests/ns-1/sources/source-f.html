


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Kosaraju</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.thealgorithms.datastructures.graphs</a>
</div>

<h1>Coverage Summary for Class: Kosaraju (com.thealgorithms.datastructures.graphs)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Kosaraju</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/40)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.thealgorithms.datastructures.graphs;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;import java.util.Stack;
&nbsp;
&nbsp;/**
&nbsp; * Java program that implements Kosaraju Algorithm.
&nbsp; * @author Shivanagouda S A (https://github.com/shivu2002a)
&nbsp; * 
&nbsp; */
&nbsp;
&nbsp;/**
&nbsp; * Kosaraju algorithm is a linear time algorithm to find the strongly connected components of a 
&nbsp;   directed graph, which, from here onwards will be referred by SCC. It leverages the fact that the transpose
&nbsp;   graph (same graph with all the edges reversed) has exactly the same SCCs as the original graph.
&nbsp;    
&nbsp; * A graph is said to be strongly connected if every vertex is reachable from every other vertex. 
&nbsp;   The SCCs of a directed graph form a partition into subgraphs that are themselves strongly connected.
&nbsp;   Single node is always a SCC.
&nbsp;
&nbsp; * Example:
&nbsp;
&nbsp;    0 &lt;--- 2 -------&gt; 3 -------- &gt; 4 ---- &gt; 7
&nbsp;    |     ^                      | ^       ^
&nbsp;    |    /                       |  \     /
&nbsp;    |   /                        |   \   /
&nbsp;    v  /                         v    \ /
&nbsp;    1                            5 --&gt; 6 
&nbsp;
&nbsp;    For the above graph, the SCC list goes as follows:
&nbsp;    0, 1, 2 
&nbsp;    3
&nbsp;    4, 5, 6
&nbsp;    7
&nbsp;    
&nbsp;    We can also see that order of the nodes in an SCC doesn&#39;t matter since they are in cycle.
&nbsp;
&nbsp; {@summary}
&nbsp; * Kosaraju Algorithm: 
&nbsp;    1. Perform DFS traversal of the graph. Push node to stack before returning. This gives edges sorted by lowest finish time.
&nbsp;    2. Find the transpose graph by reversing the edges.
&nbsp;    3. Pop nodes one by one from the stack and again to DFS on the modified graph.
&nbsp;
&nbsp;    The transpose graph of the above graph:
&nbsp;     0 ---&gt; 2 &lt;------- 3 &lt;------- 4 &lt;------ 7
&nbsp;    ^     /                      ^ \       /
&nbsp;    |    /                       |  \     /
&nbsp;    |   /                        |   \   /
&nbsp;    |  v                         |    v v
&nbsp;    1                            5 &lt;--- 6 
&nbsp;
&nbsp;    We can observe that this graph has the same SCC as that of original graph.
&nbsp;
&nbsp; */
&nbsp;
<b class="nc">&nbsp;public class Kosaraju {</b>
&nbsp;
&nbsp;    // Sort edges according to lowest finish time
<b class="nc">&nbsp;    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</b>
&nbsp;
&nbsp;    //Store each component
<b class="nc">&nbsp;    private List&lt;Integer&gt; scc = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    //All the strongly connected components
<b class="nc">&nbsp;    private List&lt;List&lt;Integer&gt;&gt; sccsList = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * 
&nbsp;     * @param v Node count
&nbsp;     * @param list Adjacency list of graph
&nbsp;     * @return List of SCCs
&nbsp;     */
&nbsp;    public List&lt;List&lt;Integer&gt;&gt; kosaraju(int v, List&lt;List&lt;Integer&gt;&gt; list){
&nbsp;        
<b class="nc">&nbsp;        sortEdgesByLowestFinishTime(v, list);</b>
&nbsp;        
<b class="nc">&nbsp;        List&lt;List&lt;Integer&gt;&gt; transposeGraph = createTransposeMatrix(v, list);</b>
&nbsp;
<b class="nc">&nbsp;        findStronglyConnectedComponents(v, transposeGraph);</b>
&nbsp;        
<b class="nc">&nbsp;        return sccsList;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void sortEdgesByLowestFinishTime(int v, List&lt;List&lt;Integer&gt;&gt; list){
<b class="nc">&nbsp;        int vis[] = new int[v];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; v; i++) {</b>
<b class="nc">&nbsp;            if(vis[i] == 0){</b>
<b class="nc">&nbsp;                dfs(i, vis, list);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;List&lt;Integer&gt;&gt; createTransposeMatrix(int v, List&lt;List&lt;Integer&gt;&gt; list) {
<b class="nc">&nbsp;        var transposeGraph = new ArrayList&lt;List&lt;Integer&gt;&gt;(v);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; v; i++) {</b>
<b class="nc">&nbsp;            transposeGraph.add(new ArrayList&lt;&gt;());</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int i = 0; i &lt; v; i++) {</b>
<b class="nc">&nbsp;            for (Integer neigh : list.get(i)) {</b>
<b class="nc">&nbsp;                transposeGraph.get(neigh).add(i);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return transposeGraph;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * 
&nbsp;     * @param v Node count
&nbsp;     * @param transposeGraph Transpose of the given adjacency list
&nbsp;     */
&nbsp;    public void findStronglyConnectedComponents(int v, List&lt;List&lt;Integer&gt;&gt; transposeGraph){
<b class="nc">&nbsp;        int vis[] = new int[v];</b>
<b class="nc">&nbsp;        while (!stack.isEmpty()) {</b>
<b class="nc">&nbsp;            var node = stack.pop();</b>
<b class="nc">&nbsp;            if(vis[node] == 0){</b>
<b class="nc">&nbsp;                dfs2(node, vis, transposeGraph);</b>
<b class="nc">&nbsp;                sccsList.add(scc);</b>
<b class="nc">&nbsp;                scc = new ArrayList&lt;&gt;();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    //Dfs to store the nodes in order of lowest finish time
&nbsp;    private void dfs(int node, int vis[], List&lt;List&lt;Integer&gt;&gt; list){
<b class="nc">&nbsp;        vis[node] = 1;</b>
<b class="nc">&nbsp;        for(Integer neighbour : list.get(node)){</b>
<b class="nc">&nbsp;            if(vis[neighbour] == 0)</b>
<b class="nc">&nbsp;                dfs(neighbour, vis, list);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        stack.push(node);</b>
&nbsp;    }
&nbsp;
&nbsp;    //Dfs to find all the nodes of each strongly connected component
&nbsp;    private void dfs2(int node, int vis[], List&lt;List&lt;Integer&gt;&gt; list){
<b class="nc">&nbsp;        vis[node] = 1;</b>
<b class="nc">&nbsp;        for(Integer neighbour : list.get(node)){</b>
<b class="nc">&nbsp;            if(vis[neighbour] == 0)</b>
<b class="nc">&nbsp;                dfs2(neighbour, vis, list);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        scc.add(node);</b>
&nbsp;    }
&nbsp;    
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-02-20 16:32</div>
</div>
</body>
</html>
